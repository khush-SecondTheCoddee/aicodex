#!/usr/bin/env bash
set -euo pipefail

APP_NAME="TermuxCoderAI"
APP_VERSION="3.0.0"
DEFAULT_MODE="code"
MAX_INPUT_CHARS=5000
MAX_HISTORY_LINES=2000
STATE_DIR="${HOME}/.termux_coder_ai"
HISTORY_FILE="${STATE_DIR}/history.log"
LAST_OUTPUT_FILE="${STATE_DIR}/last_output.txt"
CONFIG_FILE="${STATE_DIR}/config"
LOG_FILE="${STATE_DIR}/app.log"

umask 077
mkdir -p "$STATE_DIR"
touch "$HISTORY_FILE" "$LAST_OUTPUT_FILE" "$CONFIG_FILE" "$LOG_FILE"
MODE="$DEFAULT_MODE"

log() { printf '%s | %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" "$*" >> "$LOG_FILE"; }
trim() { awk '{$1=$1;print}' <<<"$*"; }
lower() { tr '[:upper:]' '[:lower:]' <<<"$*"; }

safe_write_file() {
  local target="$1" tmp="${1}.tmp.$$"
  cat > "$tmp"
  mv "$tmp" "$target"
}

write_last_output() { safe_write_file "$LAST_OUTPUT_FILE"; }

append_history() {
  local q="$1"
  printf '%s | mode=%s | %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" "$MODE" "$q" >> "$HISTORY_FILE"
  local lines
  lines=$(wc -l < "$HISTORY_FILE" | awk '{print $1}')
  if (( lines > MAX_HISTORY_LINES )); then
    tail -n "$MAX_HISTORY_LINES" "$HISTORY_FILE" > "${HISTORY_FILE}.tmp"
    mv "${HISTORY_FILE}.tmp" "$HISTORY_FILE"
  fi
}

load_config() {
  if [[ -s "$CONFIG_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$CONFIG_FILE" || true
  fi
  MODE="${MODE:-$DEFAULT_MODE}"
}

save_config() {
  cat <<EOF | safe_write_file "$CONFIG_FILE"
MODE=$MODE
EOF
}

banner() {
  cat <<EOF
==========================================================
$APP_NAME v$APP_VERSION
Dependency-free local coding model for Termux (non-root)
==========================================================
Commands: :help :mode <chat|code|shell> :status :history :save <file> :quit
CLI flags: --prompt "..." --version --selftest
EOF
}

help_text() {
  cat <<'EOF'
Modes:
  code  - synthesize code from prompt features
  chat  - discuss engineering choices
  shell - suggest terminal workflow

Commands:
  :help
  :mode <chat|code|shell>
  :status
  :history
  :save <file>
  :quit

This uses an on-device rule+scoring model (no package install, no network).
EOF
}

status_text() {
  local lines
  lines=$(wc -l < "$HISTORY_FILE" | awk '{print $1}')
  cat <<EOF
app=$APP_NAME
version=$APP_VERSION
mode=$MODE
state_dir=$STATE_DIR
history_lines=$lines
max_input_chars=$MAX_INPUT_CHARS
EOF
}

contains() { [[ "$1" == *"$2"* ]]; }

detect_lang() {
  local q="$1"
  contains "$q" "python" && { echo "python"; return; }
  contains "$q" "bash" && { echo "bash"; return; }
  contains "$q" "shell" && { echo "bash"; return; }
  contains "$q" "c++" && { echo "cpp"; return; }
  contains "$q" "cpp" && { echo "cpp"; return; }
  contains "$q" "javascript" && { echo "javascript"; return; }
  contains "$q" "node" && { echo "javascript"; return; }
  contains "$q" "c " && { echo "c"; return; }
  echo "python"
}

score_feature() {
  local q="$1" key="$2" score=0
  case "$key" in
    fileio)
      contains "$q" "file" && score=$((score+2))
      contains "$q" "json" && score=$((score+2))
      contains "$q" "save" && score=$((score+1))
      ;;
    cli)
      contains "$q" "cli" && score=$((score+2))
      contains "$q" "command" && score=$((score+1))
      contains "$q" "args" && score=$((score+1))
      ;;
    class)
      contains "$q" "class" && score=$((score+3))
      contains "$q" "object" && score=$((score+1))
      ;;
    http)
      contains "$q" "http" && score=$((score+2))
      contains "$q" "api" && score=$((score+2))
      contains "$q" "server" && score=$((score+2))
      ;;
    algo)
      contains "$q" "sort" && score=$((score+2))
      contains "$q" "search" && score=$((score+2))
      contains "$q" "algorithm" && score=$((score+2))
      ;;
  esac
  echo "$score"
}

pick_name() {
  local q="$1"
  if contains "$q" "todo"; then echo "todo"; return; fi
  if contains "$q" "api"; then echo "api_tool"; return; fi
  if contains "$q" "backup"; then echo "backup"; return; fi
  if contains "$q" "search"; then echo "searcher"; return; fi
  echo "app"
}

synthesize_python() {
  local q="$1" name="$2"
  local fileio cli class http algo
  fileio=$(score_feature "$q" fileio)
  cli=$(score_feature "$q" cli)
  class=$(score_feature "$q" class)
  http=$(score_feature "$q" http)
  algo=$(score_feature "$q" algo)

  echo '```python'
  echo '#!/usr/bin/env python3'
  echo '"""Generated by TermuxCoderAI local model."""'
  echo 'import sys'
  (( fileio > 0 )) && echo 'import json'
  (( fileio > 0 )) && echo 'from pathlib import Path'
  echo

  if (( class > 0 )); then
    echo "class ${name^}Service:"
    echo '    def __init__(self):'
    echo '        self.items = []'
    echo
    echo '    def add(self, value: str) -> None:'
    echo '        self.items.append(value)'
    echo
    echo '    def list_all(self):'
    echo '        return list(self.items)'
    echo
  fi

  if (( fileio > 0 )); then
    echo 'DB = Path("data.json")'
    echo
    echo 'def load_data():'
    echo '    if not DB.exists():'
    echo '        return []'
    echo '    try:'
    echo '        return json.loads(DB.read_text(encoding="utf-8"))'
    echo '    except Exception:'
    echo '        return []'
    echo
    echo 'def save_data(items):'
    echo '    tmp = DB.with_suffix(".tmp")'
    echo '    tmp.write_text(json.dumps(items, indent=2, ensure_ascii=False), encoding="utf-8")'
    echo '    tmp.replace(DB)'
    echo
  fi

  if (( algo > 0 )); then
    echo 'def binary_search(arr, target):'
    echo '    lo, hi = 0, len(arr) - 1'
    echo '    while lo <= hi:'
    echo '        mid = (lo + hi) // 2'
    echo '        if arr[mid] == target:'
    echo '            return mid'
    echo '        if arr[mid] < target:'
    echo '            lo = mid + 1'
    echo '        else:'
    echo '            hi = mid - 1'
    echo '    return -1'
    echo
  fi

  echo 'def main(argv):'
  if (( cli > 0 )); then
    echo '    if len(argv) < 2:'
    echo '        print("Usage: app.py <command> [args]")'
    echo '        return 1'
    (( fileio > 0 )) && echo '    items = load_data()'
    echo '    cmd = argv[1]'
    echo '    if cmd == "add":'
    (( fileio > 0 )) && echo '        text = " ".join(argv[2:]).strip() or "item"'
    (( fileio > 0 )) && echo '        items.append({"text": text, "done": False})'
    (( fileio > 0 )) && echo '        save_data(items)'
    echo '        print("ok")'
    echo '        return 0'
    echo '    if cmd == "list":'
    (( fileio > 0 )) && echo '        for i, item in enumerate(items, 1):'
    (( fileio > 0 )) && echo '            print(f"{i}. {item}")'
    (( fileio == 0 )) && echo '        print("no storage configured")'
    echo '        return 0'
    echo '    print("unknown command")'
    echo '    return 1'
  else
    echo '    print("ready")'
    echo '    return 0'
  fi

  echo
  echo 'if __name__ == "__main__":'
  echo '    raise SystemExit(main(sys.argv))'
  echo '```'
}

synthesize_bash() {
  local q="$1" name="$2"
  local fileio cli
  fileio=$(score_feature "$q" fileio)
  cli=$(score_feature "$q" cli)

  echo '```bash'
  echo '#!/usr/bin/env bash'
  echo 'set -euo pipefail'
  echo
  echo "APP_NAME="$name""
  if (( fileio > 0 )); then
    echo 'DB="data.txt"'
  fi
  echo
  echo 'main() {'
  if (( cli > 0 )); then
    echo '  if [[ $# -lt 1 ]]; then'
    echo '    echo "Usage: ./app.sh <command> [args]"'
    echo '    return 1'
    echo '  fi'
    echo '  local cmd="$1"; shift || true'
    echo '  case "$cmd" in'
    echo '    add)'
    (( fileio > 0 )) && echo '      echo "$*" >> "$DB"'
    (( fileio == 0 )) && echo '      echo "added: $*"'
    echo '      ;;'
    echo '    list)'
    (( fileio > 0 )) && echo '      [[ -f "$DB" ]] && nl -ba "$DB" || echo "empty"'
    (( fileio == 0 )) && echo '      echo "no storage configured"'
    echo '      ;;'
    echo '    *) echo "unknown command"; return 1 ;;'
    echo '  esac'
  else
    echo '  echo "ready"'
  fi
  echo '}'
  echo
  echo 'main "$@"'
  echo '```'
}

synthesize_c_like() {
  local lang="$1"
  [[ "$lang" == "cpp" ]] && {
    cat <<'EOF'
```cpp
#include <iostream>
#include <vector>
#include <string>

int main(int argc, char** argv) {
    std::vector<std::string> args(argv + 1, argv + argc);
    if (args.empty()) {
        std::cout << "usage: app <text>" << std::endl;
        return 1;
    }
    std::cout << "ok: " << args[0] << std::endl;
    return 0;
}
```
EOF
    return
  }
  cat <<'EOF'
```c
#include <stdio.h>

int main(int argc, char **argv) {
    if (argc < 2) {
        puts("usage: app <text>");
        return 1;
    }
    printf("ok: %s\n", argv[1]);
    return 0;
}
```
EOF
}

synthesize_js() {
  cat <<'EOF'
```javascript
'use strict';

function main(args) {
  if (args.length < 1) {
    console.error('usage: node app.js <text>');
    process.exit(1);
  }
  console.log(`ok: ${args[0]}`);
}

main(process.argv.slice(2));
```
EOF
}

respond_code() {
  local q="$1" lq lang name
  lq="$(lower "$q")"
  lang="$(detect_lang "$lq")"
  name="$(pick_name "$lq")"

  case "$lang" in
    python) synthesize_python "$lq" "$name" ;;
    bash) synthesize_bash "$lq" "$name" ;;
    c|cpp) synthesize_c_like "$lang" ;;
    javascript) synthesize_js ;;
    *) synthesize_python "$lq" "$name" ;;
  esac
}

respond_chat() {
  local q="$1"
  cat <<EOF
$APP_NAME analysis:
- Prompt: "$q"
- I can break this into architecture, implementation, and tests.
- Use :mode code for direct code synthesis.
EOF
}

respond_shell() {
  local q="$1"
  cat <<EOF
Shell plan for "$q":
1) mkdir -p project && cd project
2) generate file(s) with here-doc blocks
3) validate with bash -n / python3 -m py_compile
4) run and profile with time
EOF
}

handle_command() {
  local line="$1" cmd arg1
  cmd="$(awk '{print $1}' <<<"$line")"
  arg1="$(awk '{print $2}' <<<"$line")"
  case "$cmd" in
    :help) help_text | tee /dev/stderr | write_last_output ;;
    :mode)
      if [[ "$arg1" =~ ^(chat|code|shell)$ ]]; then
        MODE="$arg1"; save_config
        echo "mode=$MODE" | tee /dev/stderr | write_last_output
      else
        echo "Usage: :mode <chat|code|shell>" | tee /dev/stderr | write_last_output
      fi
      ;;
    :status) status_text | tee /dev/stderr | write_last_output ;;
    :history) tail -n 20 "$HISTORY_FILE" | tee /dev/stderr | write_last_output ;;
    :save)
      [[ -n "$arg1" ]] || { echo "Usage: :save <file>" | tee /dev/stderr | write_last_output; return 0; }
      cp "$LAST_OUTPUT_FILE" "$arg1"
      echo "saved=$arg1" | tee /dev/stderr | write_last_output
      ;;
    :quit) exit 0 ;;
    *) return 1 ;;
  esac
}

respond_for_mode() {
  local q="$1"
  case "$MODE" in
    code) respond_code "$q" ;;
    chat) respond_chat "$q" ;;
    shell) respond_shell "$q" ;;
    *) MODE="code"; save_config; respond_code "$q" ;;
  esac
}

selftest() {
  [[ -d "$STATE_DIR" ]] || return 1
  [[ -f "$HISTORY_FILE" ]] || return 1
  [[ -f "$LAST_OUTPUT_FILE" ]] || return 1
  [[ "$MODE" =~ ^(chat|code|shell)$ ]] || return 1
  echo "SELFTEST PASS"
}

one_shot() {
  local prompt="$1"
  [[ ${#prompt} -le MAX_INPUT_CHARS ]] || { echo "input too long"; return 1; }
  append_history "$prompt"
  respond_for_mode "$prompt" | tee /dev/stderr | write_last_output
}

loop() {
  banner
  while true; do
    printf '\n[%s:%s]> ' "$APP_NAME" "$MODE"
    IFS= read -r line || break
    line="$(trim "$line")"
    [[ -z "$line" ]] && continue
    [[ ${#line} -le MAX_INPUT_CHARS ]] || { echo "input too long" | tee /dev/stderr | write_last_output; continue; }

    if [[ "${line:0:1}" == ":" ]]; then
      handle_command "$line" && continue
      echo "Unknown command" | tee /dev/stderr | write_last_output
      continue
    fi

    append_history "$line"
    respond_for_mode "$line" | tee /dev/stderr | write_last_output
  done
}

main() {
  load_config
  log "start version=$APP_VERSION mode=$MODE"
  case "${1:-}" in
    --version) echo "$APP_NAME $APP_VERSION"; exit 0 ;;
    --selftest) selftest; exit $? ;;
    --prompt) shift; one_shot "$*"; exit 0 ;;
  esac
  loop
}

main "$@"
